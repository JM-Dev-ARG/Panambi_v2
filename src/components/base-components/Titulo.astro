---
interface Props {
  title: string;
  subtitle: string;
}
const { title, subtitle } = Astro.props;

const tituloPalabras = title.split(" ");
const subtitlePalabras = subtitle.split(" ");

---

<div
  class="text-negro mb-16 flex w-full flex-col items-center justify-center gap-2"
>
  <h3
 
    class="titulo1 text-center text-xl font-normal uppercase md:text-2xl lg:text-4xl "
    
  > {
    tituloPalabras.map((palabra, palabraIndex) =>
      <span class="palabra tracking-panambi-nav inline-block pr-4">
        {
          palabra.split("").map((char, charIndex) => {
            // calculamos el delay global
            const globalIndex = tituloPalabras
              .slice(0, palabraIndex) // todas las palabras anteriores
              .join("")               // las juntamos
              .length + palabraIndex  // sumamos espacios
              + charIndex;            // sumamos el Ã­ndice de la letra actual

            return (
              <span
                class="titulo__caracter inline-block"
                style={`animation-delay: ${globalIndex * 0.05}s`}
              >
                {char}
              </span>
            )
          })
        }
      </span>
    )
  }
  </h3>
  <h2
    
    class=" titulo2 font-titulo md:leading-9 lg:leading-14 w-full text-balance text-center text-3xl font-black uppercase leading-8 tracking-wide md:text-4xl lg:text-6xl  "
    data-texto={subtitle}
  >
    {
    subtitlePalabras.map((palabra, palabraIndex) =>
      <span class="palabra inline-block pr-4">
        {
          palabra.split("").map((char, charIndex) => {
            // calculamos el delay global
            const globalIndex = tituloPalabras
              .slice(0, palabraIndex) // todas las palabras anteriores
              .join("")               // las juntamos
              .length + palabraIndex  // sumamos espacios
              + charIndex;            // sumamos el Ã­ndice de la letra actual

            return (
              <span
                class="subtitle__caracter inline-block"
                style={`animation-delay: ${globalIndex * 0.05}s`}
              >
                {char}
              </span>
            )
          })
        }
      </span>
    )
  }
  </h2>


</div>

<style>
.titulo__caracter,
.subtitle__caracter {
  display: inline-block;
  opacity: 0;
  transform: translateY(100%);
  animation: slide-in 0.6s ease-out forwards;
  animation-play-state: paused; /* ðŸ”‘ se pausa hasta que la activemos */
}

.animate {
  animation-play-state: running; /* ðŸ”‘ con esta clase arranca */
}

@keyframes slide-in {
  0% {
    opacity: 0;
    transform: translateY(100%);
  }
  100% {
    opacity: 1;
    transform: translateY(0);
  }
}
</style>


<script>
  /* document.addEventListener("astro:page-load", () => {
    const palabra = document.querySelectorAll(".palabra") as NodeListOf<HTMLElement>;
    const titulo = document.querySelectorAll(".titulo__caracter, .subtitle__caracter") as NodeListOf<HTMLElement>;

      const observer = new IntersectionObserver((entries) => {
        setTimeout(() => {

          entries.forEach((entry) => {
            if (entry.isIntersecting) {
              entry.target.classList.add("animate-title");
              observer.unobserve(entry.target);
            }
          });
        }, 200);
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            entry.target.classList.add("animate-title");
            observer.unobserve(entry.target);
          }
        })
      }
        
      , { threshold: 0.1 });
      titulo.forEach((char) => {
        observer.observe(char);
      }
      );

      

  });
  

        */

        document.addEventListener("astro:page-load", () => {
  const caracteres = document.querySelectorAll(".titulo__caracter, .subtitle__caracter") as NodeListOf<HTMLElement>;

  const observer = new IntersectionObserver(
    (entries, obs) => {
      entries.forEach((entry) => {
        if (entry.isIntersecting) {
          entry.target.classList.add("animate");
          obs.unobserve(entry.target); // deja de observarlo
        }
      });
    },
    { threshold: 0.1 }
  );

  caracteres.forEach((char) => observer.observe(char));
});
    
    
</script>
