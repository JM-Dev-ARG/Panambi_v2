---
interface Props {
  title: string;
  subtitle: string;
  textNegro?: boolean;
  marginBottom?: boolean;
}
const { title, subtitle, textNegro = true, marginBottom = true } = Astro.props;

const tituloPalabras = title.split(" ");
const subtitlePalabras = subtitle.split(" ");
---

<div
  class=`flex w-full flex-col items-center justify-center gap-2 ${textNegro ?'text-negro':'text-neutral-100'} ${marginBottom ? 'mb-8' : ''}`
>
  <h3
    class="titulo1 text-center text-xl font-normal uppercase md:text-2xl lg:text-4xl"
  >
    {
      tituloPalabras.map((palabra, palabraIndex) => (
        <span class="palabra tracking-panambi-nav inline-block">
          {palabra.split("").map((char, charIndex) => {
            // calculamos el delay global
            const globalIndex =
              tituloPalabras
                .slice(0, palabraIndex) // todas las palabras anteriores
                .join("").length + // las juntamos
              palabraIndex + // sumamos espacios
              charIndex; // sumamos el Ã­ndice de la letra actual

            return (
              <span
                class="titulo__caracter inline-block"
                style={`animation-delay: ${globalIndex * 0.03}s`}
              >
                {char}
              </span>
            );
          })}
          {palabraIndex !== tituloPalabras.length - 1 && (
            <span
              class="titulo__caracter inline-block"
              style={`animation-delay: ${(palabra.length + palabraIndex) * 0.03}s`}
            >
              {" "}
            </span>
          )}
        </span>
      ))
    }
  </h3>
  <h2
    class="titulo2 font-titulo lg:leading-14 w-full text-balance text-center text-3xl font-black uppercase leading-8 tracking-wide md:text-4xl md:leading-9 lg:text-6xl"
    data-texto={subtitle}
  >
    {
      subtitlePalabras.map((palabra, palabraIndex) => (
        <span class="palabra inline-block">
          {palabra.split("").map((char, charIndex) => {
            // calculamos el delay global
            const globalIndex =
              tituloPalabras
                .slice(0, palabraIndex) // todas las palabras anteriores
                .join("").length + // las juntamos
              palabraIndex + // sumamos espacios
              charIndex; // sumamos el Ã­ndice de la letra actual

            return (
              <span
                class="titulo__caracter inline-block"
                style={`animation-delay: ${globalIndex * 0.03}s`}
              >
                {char}
              </span>
            );
          })}
          {palabraIndex !== subtitlePalabras.length - 1 && (
            <span
              class="titulo__caracter inline-block"
              style={`animation-delay: ${(palabra.length + palabraIndex) * 0.03}s`}
            >
              {" "}
            </span>
          )}
        </span>
      ))
    }
  </h2>
</div>

<style>
  .titulo__caracter,
  .subtitle__caracter {
    display: inline-block;
    opacity: 0;
    transform: translateY(100%);
    animation: slide-in 0.3s ease-out forwards;
    animation-play-state: paused; /* ðŸ”‘ se pausa hasta que la activemos */
  }

  .animate {
    animation-play-state: running; /* ðŸ”‘ con esta clase arranca */
  }

  @keyframes slide-in {
    0% {
      opacity: 0;
      transform: translateY(100%);
    }
    100% {
      opacity: 1;
      transform: translateY(0);
    }
  }
</style>

<script>
  document.addEventListener("astro:page-load", () => {
    const caracteres = document.querySelectorAll(
      ".titulo__caracter, .subtitle__caracter",
    ) as NodeListOf<HTMLElement>;

    const observer = new IntersectionObserver(
      (entries, obs) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            entry.target.classList.add("animate");
            obs.unobserve(entry.target); // deja de observarlo
          }
        });
      },
      { threshold: 0.1 },
    );

    caracteres.forEach((char) => observer.observe(char));
  });
</script>
